
import json
from datetime import date, datetime, timedelta
from typing import Dict, List, Any
from django.utils import timezone
from django.db import transaction
from .models import StudyPlan, StudyPlanItem
from stu_accounts.models import StudentAccount
import calendar


def week_monday(base_date: date = None, offset: int = 0) -> date:
    
    if base_date is None:
        base_date = date.today()
    
    # Python weekday(): Monday=0 .. Sunday=6
    monday = base_date - timedelta(days=base_date.weekday())
    monday += timedelta(days=offset * 7)
    return monday


def map_ai_result_to_weekly_format(ai_result: Dict[str, Any], timezone_str: str = 'Australia/Sydney') -> Dict[int, List[Dict]]:
    """
    Map the plan results generated by AI to the weekly plan format required by the frontend
    
    Args:
    Ai_desult: The complete result returned by the AI module
    Timezone_str: User Time Zone
            
    Returns:
    Weekly plan dictionary with week offset as the key
    """
    weekly_plans = {}
    
    if not ai_result or "days" not in ai_result:
        print("‚ö†Ô∏è [MAP_AI_RESULT]days missing")
        return weekly_plans
    
    days = ai_result["days"]
    if not days:
        print("‚ö†Ô∏è [MAP_AI_RESULT] days empty")
        return weekly_plans
    
  
    first_day = datetime.strptime(days[0]["date"], "%Y-%m-%d").date()
    base_monday = week_monday(first_day)
    

    meta_by_task_id = {}
    if ai_result.get("aiSummary") and "tasks" in ai_result["aiSummary"]:
        for task in ai_result["aiSummary"]["tasks"]:
            task_id = task.get("taskId", "")
            meta_by_task_id[task_id] = {
                "taskTitle": task.get("taskTitle", task_id),
                "partsCount": len(task.get("parts", [])) if isinstance(task.get("parts"), list) else 0,
            }
    
#check all parts
    for day in days:
        day_date = datetime.strptime(day["date"], "%Y-%m-%d").date()
        week_offset = (day_date - base_monday).days // 7
        
        if week_offset not in weekly_plans:
            weekly_plans[week_offset] = []
        
        for block in day.get("blocks", []):
            task_id = block.get("taskId", "")
            course_code = task_id.split("_")[0] if "_" in task_id else task_id
            
            meta = meta_by_task_id.get(task_id, {"taskTitle": task_id, "partsCount": 0})
            

            part_id = str(block.get("partId", ""))
            part_index = None
            if part_id:
                import re
                match = re.search(r'\d+', part_id)
                if match:
                    part_index = int(match.group())
            
            # construct the format required
            plan_item = {
                "id": f"{course_code}-{task_id}" + (f"-{part_index}" if part_index is not None else ""),
                "courseId": course_code,
                "courseTitle": meta["taskTitle"],
                "partTitle": block.get("title", ""),
                "minutes": block.get("minutes", 0),
                "date": day["date"],
                "color": "#888",  
                "completed": False,
                "partIndex": part_index,
                "partsCount": meta["partsCount"],
            }
            
            weekly_plans[week_offset].append(plan_item)
    
    print(f"üìÖ [MAP_AI_RESULT] projection doneÔºågenerate {len(weekly_plans)} weeks pkan")
    for offset, items in weekly_plans.items():
        print(f"   Week {offset}: {len(items)} has parts")
    
    return weekly_plans


def _save_plan_to_database_directly(student: StudentAccount, weekly_plans: Dict[int, List[Dict]], ai_details: Dict[str, Any]) -> Dict[str, Any]:
    """
    Directly save the weekly plan generated by AI to the database
    
    Args:
    Student: Object of Student Account
    Weekly plans: Weekly plan data (week_offset ->plan_items)
    Ai_details: Detailed content generated by AI
            
    Returns:
    Save result {"success": boolean, "plan_id": int, "error": str}
    """
    try:
        result = {"success": True, "saved": [], "plan_id": None, "error": None}
        
        # handle each week-offseet
        for offset, items in weekly_plans.items():
            if not items:
                continue
            
            week_monday_date = week_monday(offset=offset)
            
            with transaction.atomic():
                # create/update plan
                meta_data = {
                    "hasAIGeneration": True,
                    "aiDetails": ai_details,
                    "generationReason": ai_details.get("generationReason", ""),
                    "generationTime": ai_details.get("generationTime", ""),
                }
                
                plan, created = StudyPlan.objects.update_or_create(
                    student_id=student.student_id,
                    week_start_date=week_monday_date,
                    defaults={
                        "week_offset": offset,
                        "tz": "Australia/Sydney",
                        "source": "ai",
                        "meta": meta_data,
                    },
                )
        
                if not created:
                    print(f"üîÑ [SAVE_PLAN] Detected update operation, Plan ID: {plan.id}")
                    print(f"üîÑ [SAVE_PLAN] Preparing to update meta data: {meta_data}")
                    updated_count = StudyPlan.objects.filter(id=plan.id).update(
                        week_offset=offset,
                        tz="Australia/Sydney",
                        source="ai",
                        meta=meta_data
                    )
                    print(f"üîÑ [SAVE_PLAN] update {updated_count} meta data")
                else:
                    print(f"‚úÖ [SAVE_PLAN] create new planÔºåID: {plan.id}")
                
                # clear old plan
                StudyPlanItem.objects.filter(plan=plan).delete()
                
           
                plan_items = []
                for item in items:
                    try:
                   
                        task_id = None
                        parts = str(item.get("id", "")).split("-")
                        if len(parts) >= 2:
                            task_id = parts[1]
                        
                        plan_items.append(StudyPlanItem(
                            plan=plan,
                            external_item_id=item.get("id", ""),
                            course_code=item.get("courseId", ""),
                            course_title=item.get("courseTitle", ""),
                            scheduled_date=datetime.strptime(item["date"], "%Y-%m-%d").date() if item.get("date") else week_monday_date,
                            minutes=int(item.get("minutes", 0)),
                            part_index=item.get("partIndex", 0),
                            parts_count=item.get("partsCount", 0),
                            part_title=item.get("partTitle", ""),
                            color=item.get("color", "#888"),
                            completed=item.get("completed", False),
                            completed_at=timezone.now() if item.get("completed") else None,
                            task_id=task_id,
                        ))
                    except Exception as item_error:
                        print(f"‚ö†Ô∏è sth wrong!: {item_error}, part: {item}")
                        continue
                
                if plan_items:
                    StudyPlanItem.objects.bulk_create(plan_items)
                
                result["saved"].append({
                    "offset": offset,
                    "week_start_date": week_monday_date.isoformat(),
                    "plan_id": plan.id,
                    "created": created,
                    "items": len(plan_items),
                })
                
                if result["plan_id"] is None:
                    result["plan_id"] = plan.id
        
        print(f"‚úÖ [SAVE_PLAN_DIRECTLY] save successfully! {len(result['saved'])} weeks plan")
        return result
        
    except Exception as e:
        error_msg = f"save to write into db: {str(e)}"
        print(f"‚ùå [SAVE_PLAN_DIRECTLY] {error_msg}")
        return {"success": False, "error": error_msg, "plan_id": None}