// src/services/aiPlanServices.ts
import type { PlanItem, WeeklyPlan } from '../store/preferencesStore';
import { coursesStore } from '../store/coursesStore';
import { apiService } from '../services/api';
import { aiChatService } from '../services/aiChatService';

// ‚Äî‚ÄîTool: Return the given date to the Monday of the week (local time zone)‚Äî‚Äî
function weekMonday(d: Date) {
  const dd = new Date(d);
  const wd = dd.getDay() || 7;           
  dd.setHours(0, 0, 0, 0);
  dd.setDate(dd.getDate() - (wd - 1));   // back to mon
  return dd;
}

//‚Äî‚ÄîTool: Calculate the week offset difference (integer) of the "Monday" where two dates are located‚Äî‚Äî
function weekDiff(a: Date, b: Date) {
  const msPerWeek = 7 * 24 * 60 * 60 * 1000;
  return Math.round((weekMonday(a).getTime() - weekMonday(b).getTime()) / msPerWeek);
}

/**
*Core: Map the backend aiPlan to the frontend Weekly Plan (with week offset as the key)
*Expected aiPlan.days structure: [{date: 'YYYY-MM-DD', blocks: [{taskId, partId, title, minutes,...}}]
*Expected aiPlan.aiSummary.tasks: [{taskId, taskTitle, parts: [...]}]
 */
export function mapAiPlanToWeeklyPlan(aiPlan: any): WeeklyPlan {
  const weekly: WeeklyPlan = {};
  if (!aiPlan || !Array.isArray(aiPlan.days)) return weekly;

  // index (taskId -> { taskTitle, partsCount })
  const metaByTaskId: Record<string, { taskTitle: string; partsCount: number }> = {};
  if (aiPlan.aiSummary?.tasks) {
    for (const t of aiPlan.aiSummary.tasks) {
      metaByTaskId[t.taskId] = {
        taskTitle: t.taskTitle || t.taskId,
        partsCount: Array.isArray(t.parts) ? t.parts.length : 0,
      };
    }
  }

  // The weekStart returned by the backend serves as the baseline week; Otherwise, use the Monday of the first day; I can't use today's Monday anymore
  const baseWeekStart =
    aiPlan.weekStart
      ? weekMonday(new Date(aiPlan.weekStart))
      : (aiPlan.days.length
          ? weekMonday(new Date(aiPlan.days[0].date))
          : weekMonday(new Date()));

  //Traverse daily and its blocks, generate PlanItems and classify them by weekly offset
  for (const day of aiPlan.days) {
    const dateStr: string = day.date;     //'YYYY-MM-DD'
    const dateObj = new Date(dateStr);
    const offset = weekDiff(dateObj, baseWeekStart);
    if (!weekly[offset]) weekly[offset] = [];

    for (const b of (day.blocks || [])) {
      const taskId: string = b.taskId;                     //  "COMP9900_3"
      const courseId = taskId.split('_')[0] || taskId;     // "COMP9900"
      const meta = metaByTaskId[taskId] || { taskTitle: taskId, partsCount: 0 };

      // Extract sequence number from partId (p1->1)
      const maybeIndex = parseInt(String(b.partId).replace(/\D+/g, ''), 10);
      const partIndex = Number.isFinite(maybeIndex) ? maybeIndex : undefined;

      //Unified ID Specification:`$ {courseId}- ${taskId} `, ensure availability with deadlines`$ {courseId}- ${taskId} ` Match
      //The taskId returned by the backend AI may be "COMP9900_3", and the number 3 needs to be extracted as the real task ID
      const numericIdMatch = String(taskId).match(/(\d+)$|_(\d+)$/);
      const normalizedTaskId = numericIdMatch ? (numericIdMatch[1] || numericIdMatch[2]) : String(taskId);

      const item: PlanItem = {
        id: `${courseId}-${normalizedTaskId}` + (Number.isFinite(partIndex as any) ? `-${partIndex}` : ''),
        courseId,
        courseTitle: meta.taskTitle,        //  "COMP9900 - Final Presentation"
        partTitle: b.title,                 // "Part 1" 
        minutes: b.minutes,                 // 60
        date: dateStr,                      // YYYY-MM-DDÔºå
        color: coursesStore.getColorByCourse(courseId) || '#888',
        completed: false,
        partIndex,
        partsCount: meta.partsCount,
      };
      
      // Debugging information: Check the titles generated by Gemini
      console.log(`üîç [mapAiPlanToWeeklyPlan] Task: ${meta.taskTitle}, Part title: ${b.title}`);
      console.log(`üéØ [GEMINI_TITLE_CHECK] This is a specific title generated by Gemini: "${b.title}"`);

      weekly[offset].push(item);
    }
  }

  return weekly;
}

/**
*One step approach: Request backend AI plan ‚Üí Map to WeeklyPlan and return
*Error thrown in case of failure, outer layer can choose to fallback to local generateWeeklyPlan()
 */
export async function fetchAndMapAiPlan(): Promise<WeeklyPlan> {
  const aiPlan = await apiService.generateAIPlan();
  
  console.log('üîç fetchAndMapAiPlan data received:', aiPlan);
  console.log('üîç Days data of AI plan:', aiPlan?.days);
  console.log('üîç AISummary data of AI plan:', aiPlan?.aiSummary);
  
  // check ai plan data
  if (!aiPlan || !aiPlan.ok) {
    throw new Error(aiPlan?.message || 'fail to generate ai plan');
  }
  
  // AiPlan itself is plan data (api.ts has already returned res.data)
  const planData = aiPlan;
  if (!planData || !planData.days) {
    throw new Error('The backend returns empty AI plan data. Please check your network connection or try again later');
  }
  
  // Check if the backend has saved the plan
  if (aiPlan.saved) {
    console.log('‚úÖ [fetchAndMapAiPlan] Backend saved plan, plan ID:', aiPlan.plan_id);
    console.log('ü§ñ [fetchAndMapAiPlan] The detailed content of AI has been included in the response');
  } else {
    console.log('‚ö†Ô∏è [fetchAndMapAiPlan] Backend plan not saved, using old logic');
    
    // If the backend does not save, use frontend save logic (compatibility)
    const weeklyPlan = mapAiPlanToWeeklyPlan(planData);
    const savePayload = {
      weeklyPlans: weeklyPlan,
      aiDetails: planData.aiDetails || null,
      generationReason: planData.aiDetails?.generationReason || '',
      generationTime: planData.aiDetails?.generationTime || null
    };
    
    const saveResult = await apiService.saveWeeklyPlansToServer(
      savePayload.weeklyPlans, 
      savePayload.aiDetails, 
      savePayload.generationReason, 
      savePayload.generationTime
    );
    
    if (!saveResult.ok) {
      console.error('‚ùå Learning plan save failed:', saveResult.error);
      throw new Error(`Learning plan save failed: ${saveResult.error || 'unknown err'}`);
    }
    
    console.log('‚úÖ The learning plan has been saved to the database through front-end logic');
  }
  
  //Map AI plan to weekly plan format for front-end display
  const weeklyPlan = mapAiPlanToWeeklyPlan(planData);
  console.log('üóìÔ∏è Mapped weekly plan:', weeklyPlan);
  
  return weeklyPlan;
}
