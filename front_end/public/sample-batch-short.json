[
  {
    "topic": "Object-Oriented Programming",
    "question": "Explain the concept of polymorphism in object-oriented programming with an example.",
    "sampleAnswer": "Polymorphism allows objects of different classes to be treated as objects of a common parent class. For example, you can have a Shape parent class with Circle and Rectangle child classes, each implementing their own draw() method differently.",
    "keyPoints": "Definition of polymorphism; inheritance; method overriding; real-world example with code",
    "score": 20,
    "difficulty": "Medium",
    "gradingCriteria": "Answer must include definition, inheritance relationship, and explanation of how different objects respond to same method call",
    "hint": "Think about how different shapes can all have a draw method but implement it differently"
  },
  {
    "topic": "Data Structures",
    "question": "Describe the difference between a stack and a queue, and provide one real-world use case for each.",
    "sampleAnswer": "A stack follows Last-In-First-Out (LIFO) principle where the last element added is the first to be removed, like a stack of plates. A queue follows First-In-First-Out (FIFO) principle, like a line at a store. Stack use case: browser back button history. Queue use case: print job scheduling.",
    "keyPoints": "LIFO vs FIFO; distinct real-world examples for both; correct understanding of insertion and removal order",
    "score": 15,
    "difficulty": "Easy",
    "gradingCriteria": "Must explain LIFO and FIFO correctly, give appropriate real-world examples",
    "hint": "Think about how items are added and removed in each structure"
  },
  {
    "topic": "Algorithm Complexity",
    "question": "What is Big O notation and why is it important in algorithm analysis?",
    "sampleAnswer": "Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards infinity. It's used to classify algorithms according to how their running time or space requirements grow as the input size grows. It's important because it helps developers compare algorithm efficiency and choose the most appropriate algorithm for their use case.",
    "keyPoints": "Mathematical notation for growth rate; describes worst-case scenario; helps compare algorithms; relates to scalability",
    "score": 25,
    "difficulty": "Hard",
    "gradingCriteria": "Must define Big O notation, explain its purpose in algorithm analysis, mention time/space complexity",
    "hint": "Focus on how performance changes as input size increases"
  }
]
